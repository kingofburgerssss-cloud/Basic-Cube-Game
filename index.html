<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>geometry dash â€” wave hell mode</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;overflow:hidden}
    canvas{display:block;background:#07101a}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize',resize);
resize();

let wave={x:300,y:canvas.height/2,radius:18,vy:0,thrust:-3.2,gravity:2.5,angle:0,speed:5};
let holding=false;
let upPressed=false;
let dead=false;
let deathTimer=0;
let invincible=0;

const trail=[];
const maxTrailLength = 200;
const obstacles=[];
const circleRadius = 60;

// generate dense, scattered obstacles
for(let i=0;i<200;i++){
  obstacles.push({
    x: i * 180 + Math.random() * 100,
    y: Math.random() * canvas.height,
    radius: circleRadius * (0.6 + Math.random() * 0.8)
  });
}

function resetGame(){
  wave={x:300,y:canvas.height/2,radius:18,vy:0,thrust:-3.2,gravity:2.5,angle:0,speed:5};
  trail.length=0;
  dead=false;
  invincible=2; // 2 seconds of invincibility after respawn
}

function startHold(){holding=true;}
function stopHold(){holding=false;}
window.addEventListener('keydown',e=>{
  if(e.code==='KeyZ'||e.code==='Space'){startHold();}
  if(e.code==='ArrowUp'){upPressed=true;}
});
window.addEventListener('keyup',e=>{
  if(e.code==='KeyZ'||e.code==='Space'){stopHold();}
  if(e.code==='ArrowUp'){upPressed=false;}
});
canvas.addEventListener('mousedown',startHold);
window.addEventListener('mouseup',stopHold);
canvas.addEventListener('touchstart',e=>{e.preventDefault();startHold();},{passive:false});
window.addEventListener('touchend',e=>{e.preventDefault();stopHold();},{passive:false});

function checkCollision(){
  if(invincible>0) return false;
  for(const obs of obstacles){
    const dx = wave.x - obs.x;
    const dy = wave.y - obs.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < wave.radius + obs.radius){
      return true;
    }
  }
  return false;
}

function update(){
  if(dead){
    deathTimer -= 1/60;
    if(deathTimer <= 0) resetGame();
    return;
  }

  if(invincible>0) invincible -= 1/60;

  wave.x += wave.speed;
  if(holding || upPressed){
    wave.y += wave.thrust;
    wave.angle = -Math.PI/4;
  } else {
    wave.y += wave.gravity;
    wave.angle = Math.PI/4;
  }

  // keep inside bounds
  if(wave.y < wave.radius) wave.y = wave.radius;
  if(wave.y > canvas.height - wave.radius) wave.y = canvas.height - wave.radius;

  if(checkCollision()){
    dead=true;
    deathTimer=3;
  }

  trail.push({x: wave.x, y: wave.y});
  if(trail.length > maxTrailLength) trail.shift();
}

function drawWave(x,y,r,a){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(a);
  ctx.beginPath();
  ctx.moveTo(r,0);
  ctx.lineTo(-r*0.8,-r*0.7);
  ctx.lineTo(-r*0.8,r*0.7);
  ctx.closePath();
  ctx.fillStyle= dead ? '#ff0000' : (invincible>0 ? 'rgba(126,252,255,0.5)' : '#7efcff');
  ctx.fill();
  ctx.restore();
}

function drawCircle(obs){
  ctx.beginPath();
  ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
  ctx.fillStyle = '#ff4f4f';
  ctx.fill();
}

function renderDeath(){
  ctx.save();
  ctx.fillStyle='rgba(255,0,0,0.7)';
  ctx.beginPath();
  ctx.arc(wave.x,wave.y,100,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function render(){
  ctx.fillStyle='rgba(7,16,32,1)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const camX = wave.x - 300;
  ctx.save();
  ctx.translate(-camX,0);

  for(const obs of obstacles){
    drawCircle(obs);
  }

  for(let i=0;i<trail.length;i++){
    ctx.save();
    ctx.translate(trail[i].x, trail[i].y);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle='rgba(126,252,255,0.5)';
    const size = wave.radius*1.4;
    ctx.fillRect(-size/2, -size/2, size, size);
    ctx.restore();
  }

  if(dead) renderDeath();
  drawWave(wave.x,wave.y,wave.radius,wave.angle);
  ctx.restore();
}

function loop(){
  update();
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
